import * as cdk from '@aws-cdk/core';
import * as iam from '@aws-cdk/aws-iam';
import * as kms from '@aws-cdk/aws-kms';
import * as s3 from '@aws-cdk/aws-s3';
import * as outputKeys from '@aws-pbmm/common-outputs/lib/stack-output';
import { S3CopyFiles } from '@custom-resources/s3-copy-files';
import { S3PublicAccessBlock } from '@custom-resources/s3-public-access-block';
import { Organizations } from '@custom-resources/organization';
import { AcceleratorConfig } from '@aws-pbmm/common-lambda/lib/config';
import { createEncryptionKeyName, createRoleName } from '@aws-pbmm/common-cdk/lib/core/accelerator-name-generator';
import {
  CentralBucketOutput,
  CentralBucketOutputType,
  LogBucketOutput,
  LogBucketOutputType,
  AesBucketOutputType,
  AesBucketOutput,
} from './outputs';
import { AccountStacks } from '../../common/account-stacks';
import { Account } from '../../utils/accounts';
import { StructuredOutput } from '../../common/structured-output';
import { createDefaultS3Bucket, createDefaultS3Key } from './shared';
import { overrideLogicalId } from '../../utils/cdk';

export interface DefaultsStep1Props {
  acceleratorPrefix: string;
  accountStacks: AccountStacks;
  accounts: Account[];
  config: AcceleratorConfig;
}

export interface DefaultsStep1Result {
  centralBucketCopy: s3.Bucket;
  centralLogBucket: s3.Bucket;
  aesLogBucket: s3.Bucket;
  accountEbsEncryptionKeys: { [accountKey: string]: kms.Key };
}

export async function step1(props: DefaultsStep1Props): Promise<DefaultsStep1Result> {
  blockS3PublicAccess(props);

  const centralBucketCopy = createCentralBucketCopy(props);
  const centralLogBucket = createCentralLogBucket(props);
  const accountEbsEncryptionKeys = createDefaultEbsEncryptionKey(props);
  const aesLogBucket = createAesLogBucket(props);
  return {
    centralBucketCopy,
    centralLogBucket,
    aesLogBucket,
    accountEbsEncryptionKeys,
  };
}

function blockS3PublicAccess(props: DefaultsStep1Props) {
  const { accountStacks, config } = props;

  for (const [accountKey, accountConfig] of config.getAccountConfigs()) {
    const accountStack = accountStacks.tryGetOrCreateAccountStack(accountKey);
    if (!accountStack) {
      console.warn(`Cannot find account stack ${accountKey}`);
      continue;
    }

    const blockPublicAccess = !accountConfig['enable-s3-public-access'];
    new S3PublicAccessBlock(accountStack, 'PublicAccessBlock', {
      blockPublicAcls: blockPublicAccess,
      blockPublicPolicy: blockPublicAccess,
      ignorePublicAcls: blockPublicAccess,
      restrictPublicBuckets: blockPublicAccess,
    });
  }
}

/**
 * Creates a bucket that contains copies of the files in the central bucket.
 */
function createCentralBucketCopy(props: DefaultsStep1Props) {
  const { accountStacks, accounts, config } = props;

  const masterAccountConfig = config['global-options']['aws-org-master'];
  const masterAccountStack = accountStacks.getOrCreateAccountStack(masterAccountConfig.account);

  // Get the location of the original central bucket
  const centralBucketName = config['global-options']['central-bucket'];
  const centralBucket = s3.Bucket.fromBucketAttributes(masterAccountStack, 'CentralBucket', {
    bucketName: centralBucketName,
  });

  const encryptionKey = new kms.Key(masterAccountStack, 'CentralBucketKey', {
    alias: 'alias/' + createEncryptionKeyName('Config-Key'),
    description: 'Key used to encrypt/decrypt the copy of central S3 bucket',
  });

  const bucket = new s3.Bucket(masterAccountStack, 'CentralBucketCopy', {
    encryptionKey,
    versioned: true,
    blockPublicAccess: s3.BlockPublicAccess.BLOCK_ALL,
    removalPolicy: cdk.RemovalPolicy.RETAIN,
  });

  // Let the bucket name be generated by CloudFormation
  // The generated bucket name is based on the stack name + logical ID + random suffix
  overrideLogicalId(bucket, `config${masterAccountStack.region}`);

  // TODO Narrow down permissions
  const accountPrincipals = accounts.map(a => new iam.AccountPrincipal(a.id));

  // Give all accounts access to use this key for decryption
  encryptionKey.addToResourcePolicy(
    new iam.PolicyStatement({
      actions: ['kms:Decrypt'],
      principals: accountPrincipals,
      resources: ['*'],
    }),
  );

  // Give all accounts access to get and list objects in this bucket
  bucket.addToResourcePolicy(
    new iam.PolicyStatement({
      actions: ['s3:Get*', 's3:List*'],
      resources: [bucket.bucketArn, bucket.arnForObjects('*')],
      principals: accountPrincipals,
    }),
  );

  // Copy files from source to destination
  const copyFiles = new S3CopyFiles(masterAccountStack, 'CopyFiles', {
    roleName: createRoleName('S3CopyFiles'),
    sourceBucket: centralBucket,
    destinationBucket: bucket,
    deleteSourceObjects: false,
    deleteSourceBucket: false,
    forceUpdate: true,
  });
  copyFiles.node.addDependency(bucket);

  new StructuredOutput<CentralBucketOutput>(masterAccountStack, 'CentralBucketOutput', {
    type: CentralBucketOutputType,
    value: {
      bucketArn: bucket.bucketArn,
      bucketName: bucket.bucketName,
      encryptionKeyArn: encryptionKey.keyArn,
    },
  });

  return bucket;
}

/**
 * Creates a bucket that contains copies of the files in the central bucket.
 */
function createCentralLogBucket(props: DefaultsStep1Props) {
  const { accountStacks, accounts, config } = props;

  const logAccountConfig = config['global-options']['central-log-services'];
  const logAccountStack = accountStacks.getOrCreateAccountStack(logAccountConfig.account);

  const organizations = new Organizations(logAccountStack, 'Organizations');

  const accountPrincipals = accounts.map(a => new iam.AccountPrincipal(a.id));
  const logKey = createDefaultS3Key({
    accountStack: logAccountStack,
  });

  const logBucket = createDefaultS3Bucket({
    accountStack: logAccountStack,
    config,
    encryptionKey: logKey,
  });

  // Allow replication from all Accelerator accounts
  logBucket.replicateFrom(accountPrincipals, organizations.organizationId, props.acceleratorPrefix);

  logBucket.addToResourcePolicy(
    new iam.PolicyStatement({
      principals: accountPrincipals,
      actions: ['s3:GetEncryptionConfiguration', 's3:PutObject'],
      resources: [logBucket.bucketArn, logBucket.arnForObjects('*')],
      conditions: {
        StringEquals: {
          'aws:PrincipalOrgID': organizations.organizationId,
        },
      },
    }),
  );

  // Allow Kinesis access bucket
  logBucket.addToResourcePolicy(
    new iam.PolicyStatement({
      principals: accountPrincipals,
      actions: [
        's3:AbortMultipartUpload',
        's3:GetBucketLocation',
        's3:GetObject',
        's3:ListBucket',
        's3:ListBucketMultipartUploads',
        's3:PutObject',
        's3:PutObjectAcl',
      ],
      resources: [logBucket.bucketArn, `${logBucket.bucketArn}/*`],
      conditions: {
        StringEquals: {
          'aws:PrincipalOrgID': organizations.organizationId,
        },
        ArnLike: {
          'aws:PrincipalARN': `arn:aws:iam::*:role/${props.acceleratorPrefix}Kinesis-*`,
        },
      },
    }),
  );

  logBucket.addToResourcePolicy(
    new iam.PolicyStatement({
      principals: [new iam.ServicePrincipal('delivery.logs.amazonaws.com')],
      actions: ['s3:PutObject'],
      resources: [`${logBucket.bucketArn}/*`],
      conditions: {
        StringEquals: {
          's3:x-amz-acl': 'bucket-owner-full-control',
        },
      },
    }),
  );

  logBucket.addToResourcePolicy(
    new iam.PolicyStatement({
      principals: [new iam.ServicePrincipal('delivery.logs.amazonaws.com')],
      actions: ['s3:GetBucketAcl'],
      resources: [`${logBucket.bucketArn}`],
    }),
  );

  logBucket.addToResourcePolicy(
    new iam.PolicyStatement({
      principals: [new iam.ServicePrincipal('cloudtrail.amazonaws.com')],
      actions: ['s3:GetBucketAcl'],
      resources: [`${logBucket.bucketArn}`],
    }),
  );

  logBucket.addToResourcePolicy(
    new iam.PolicyStatement({
      principals: [new iam.ServicePrincipal('cloudtrail.amazonaws.com')],
      actions: ['s3:PutObject'],
      resources: [`${logBucket.bucketArn}/*`],
      conditions: {
        StringEquals: {
          's3:x-amz-acl': 'bucket-owner-full-control',
        },
      },
    }),
  );

  // Allow cross account encrypt access for logArchive bucket
  logBucket.encryptionKey?.addToResourcePolicy(
    new iam.PolicyStatement({
      sid: 'Enable cross account encrypt access for S3 Cross Region Replication',
      actions: ['kms:Encrypt', 'kms:ReEncrypt*', 'kms:GenerateDataKey*', 'kms:DescribeKey'],
      principals: accountPrincipals,
      resources: ['*'],
      conditions: {
        StringEquals: {
          'aws:PrincipalOrgID': organizations.organizationId,
        },
      },
    }),
  );

  logBucket.encryptionKey?.addToResourcePolicy(
    new iam.PolicyStatement({
      sid: 'Allow CloudTrail to encrypt and describe logs',
      actions: ['kms:GenerateDataKey*', 'kms:DescribeKey'],
      principals: [new iam.ServicePrincipal('cloudtrail.amazonaws.com')],
      resources: ['*'],
    }),
  );

  new StructuredOutput<LogBucketOutput>(logAccountStack, 'LogBucketOutput', {
    type: LogBucketOutputType,
    value: {
      bucketArn: logBucket.bucketArn,
      bucketName: logBucket.bucketName,
      encryptionKeyArn: logBucket.encryptionKey!.keyArn,
    },
  });

  return logBucket;
}

/**
 * Creates a bucket that will be used to store ALB access logs.
 */
function createAesLogBucket(props: DefaultsStep1Props) {
  const { accountStacks, accounts, config } = props;

  const logAccountConfig = config['global-options']['central-log-services'];
  const logAccountStack = accountStacks.getOrCreateAccountStack(logAccountConfig.account);

  const logBucket = new s3.Bucket(logAccountStack, 'AesBucket', {
    versioned: true,
    blockPublicAccess: s3.BlockPublicAccess.BLOCK_ALL,
    encryption: s3.BucketEncryption.S3_MANAGED,
    removalPolicy: cdk.RemovalPolicy.RETAIN,
  });

  // Let the bucket name be generated by CloudFormation
  // The generated bucket name is based on the stack name + logical ID + random suffix
  overrideLogicalId(logBucket, `aes${logAccountStack.region}`);

  accounts.map(a => logBucket.grantRead(new iam.AccountPrincipal(a.id)));

  // TODO remove hard coded ELB ca-central-1 region account id
  logBucket.addToResourcePolicy(
    new iam.PolicyStatement({
      principals: [new iam.AccountPrincipal('985666609251')],
      actions: ['s3:PutObject'],
      resources: [`${logBucket.bucketArn}/*`],
    }),
  );

  logBucket.addToResourcePolicy(
    new iam.PolicyStatement({
      principals: [new iam.ServicePrincipal('delivery.logs.amazonaws.com')],
      actions: ['s3:PutObject'],
      resources: [`${logBucket.bucketArn}/*`],
      conditions: {
        StringEquals: {
          's3:x-amz-acl': 'bucket-owner-full-control',
        },
      },
    }),
  );

  logBucket.addToResourcePolicy(
    new iam.PolicyStatement({
      principals: [new iam.ServicePrincipal('delivery.logs.amazonaws.com')],
      actions: ['s3:GetBucketAcl'],
      resources: [`${logBucket.bucketArn}`],
    }),
  );

  new StructuredOutput<AesBucketOutput>(logAccountStack, 'AesLogBucketOutput', {
    type: AesBucketOutputType,
    value: {
      bucketArn: logBucket.bucketArn,
      bucketName: logBucket.bucketName,
    },
  });

  return logBucket;
}

function createDefaultEbsEncryptionKey(props: DefaultsStep1Props) {
  const { accountStacks, config } = props;

  const accountEbsEncryptionKeys: { [accountKey: string]: kms.Key } = {};
  for (const [accountKey, _] of config.getAccountConfigs()) {
    const accountStack = accountStacks.tryGetOrCreateAccountStack(accountKey);
    if (!accountStack) {
      console.warn(`Cannot find account stack ${accountKey}`);
      continue;
    }

    // Default EBS encryption key
    const key = new kms.Key(accountStack, 'EbsDefaultEncryptionKey', {
      alias: 'alias/' + createEncryptionKeyName('EBS-Key'),
      description: 'Key used to encrypt/decrypt EBS by default',
    });

    key.addToResourcePolicy(
      new iam.PolicyStatement({
        effect: iam.Effect.ALLOW,
        principals: [new iam.AccountPrincipal(cdk.Aws.ACCOUNT_ID)],
        actions: ['kms:*'],
        resources: ['*'],
      }),
    );

    accountEbsEncryptionKeys[accountKey] = key;

    // Save the output so it can be used in the state machine later
    // TODO Replace with custom resource
    new cdk.CfnOutput(accountStack, outputKeys.OUTPUT_KMS_KEY_ID_FOR_EBS_DEFAULT_ENCRYPTION, {
      value: key.keyId,
    });
  }
  return accountEbsEncryptionKeys;
}
